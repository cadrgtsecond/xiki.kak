= Xiki

Xiki is a powerful tool that acts like a combination of a file tree,
a shell,
and a plan9 style plumber.

This document aims to explain how it operates.
This buffer is enabled with Xiki.
It is recommended that you run this inside of Kakoune itself with the plugin installed
so that you can try out the commands yourself.

This buffer is not `readonly` like most Kakoune documentation.
Feel free to modify the commands to try things out.

== Xiki as a file tree

Xiki operates on *commands*,
which are single lines organized into a hierarchy.

Move your cursor on top of a command and press `<ret>` to execute it.

Pressing `<ret>` again will collapse the output of the command.

Directories and files are a kind of valid command.
Try opening your home directory.

----
~
----

The output of a Xiki command can itself be treated as a command.
So you can open and collapse nested directories.
Try locating something on your system using the file tree. 

== Xiki as a shell

By default, if Xiki can't identify something, it is executed as a shell command.

Try creating a temporary directory by executing the command below.

----
mkdir -p /tmp/xiki-tutorial && printf 'Success!'

----

Notice how the output of the command was inserted below.
This could be another command as well.

Furthermore if you have a directory, any commands under it will be executed inside that directory

----
/tmp/xiki-tutorial
  git init
  git status
  touch README.md
  ls -A
----

This can be used to manipulate files

----
/tmp/xiki-tutorial
  mkdir -p src/
  printf '#!/bin/sh\n' > src/coolcommand
  printf 'echo hello world!\n' >> src/coolcommand
  chmod +x src/coolcommand
  ./src/coolcommand
  # Try opening the src directory
  src
  # Also try collapsing and reexpanding the topmost directory
----

By commands I really do mean _any_ command

----
/tmp/xiki-tutorial
  mkdir better-src
  src
    cat coolcommand
    touch grass
    # . also works instead of ls
    .
    # This does a true cd
    # So you can copy stuff outside
    cp coolcommand ../better-src 
  better-src
  rm -rfv src
----

This feature allows Xiki to be more powerful than a regular file manager.
A regular file manager requires file manipulation to be built in,
or alternatively scripted in.
However, Xiki behaves like a shell, and so it reuses all the standard utilities
for file manipulation.

Furthermore, Xiki, residing inside Kakoune,
can make use of its powerful editing commands for file manipulation.

----
/tmp/xiki-tutorial
  # Run this following command.
  # Then select the output and run <a-s>Itouch <esc>A.txt<esc>
  # Then, execute the commands using multiple cursors
  seq 1 10
  .
  # Clean up the mess
  rm -v *.txt
----

== Xiki as a plumber

Xiki can also operate like the Plan9 plumber. Try opening the link below

----
https://www.youtube.com/watch?v=dQw4w9WgXcQ
----

However, as we have seen above, Xiki operates hierarchically,
and so is far more powerful than the plan9 plumber could be.

Whenever you run a Xiki command, Xiki will collect the "path" to your command.
The command at the top of the tree comes first,
followed by any subnodes,
and finally the command you have pressed `<ret>` on.

Then it invokes the `xiki` command with each component of the path being an argument,
`$1`, `$2` etc.
So `$1` will be the topmost command, `$2` the one below it, and so on,
with the last command being the one you pressed `<ret>` on.

`xiki` is a very simple program.

1. First, it checks if any of the patterns under `$XIKI_HOME/scripts` matches `$1` +
** Each file under `$XIKI_HOME/scripts` is an executable file
   whose name is a valid Extended Regular Expression. +

2. If none of the patterns match, it executes `$XIKI_HOME/default`

By default `XIKI_CONFIG` is set to `$XDG_CONFIG_DIR/xiki`,
which on most systems is `~/.config/xiki/`

Try looking at what all scripts are available on your system

----
~/.config/xiki/scripts
----

The best way to learn how to write custom commands is to see some examples.

=== ~
----
#!/bin/sh
[ -z "$2" ] && exec ls -p "$HOME"
cd "$HOME" || exit
shift
exec xiki "$@"
----

This pattern matches the string "~" representing the home directory.

Notice that the script begins with a shebang `#!/bin/sh`,
and is executable.
You can write Xiki scripts in any programming language.
`/bin/sh` is preferred due to its portability.

The first line checks if `$2` is empty. If this is the case, that means that this command is executed with no children.
Hence, it execs into `ls`, leaving the program.

However, if it does have children, then it does a `cd`, and then shifts its arguments.

`shift` is a shell builtin that shifts the command line arguments.
In other words +
* `$1` is removed +
* `$2` becomes `$1` +
* `$3` becomes `$2` +
* etc. +
Hence consuming the first argument.

Then, it execs into `xiki` with the modified current working directory and arguments.

This pattern is very common in Xiki scripts. +
* Check if `$2` is absent, to see if there are any children +
** If it is absent, perform some behaviour. +
* If it is present, perform some action, `shift`, and then `exec xiki "$@"` with modified arguments.

It is left an exercise to the reader to understand the more complex `~(\x2F.*)?`

=== default

Now we are ready to tackle the default `default` file.

This is the command that is run when no pattern matches.

----
#!/bin/sh
if [ -d "$1" ]; then
    [ -z "$2" ] && exec ls -p "$1"
    cd "$1" || exit
    shift
    exec xiki "$@"
fi
[ -x "$1 ] && exec "./$1"
[ -f "$1" ] && exec xdg-open "$1"
[ -z "$2" ] && exec sh -c "$1"
shift
exec xiki "$@"
----

The first part is identical to our example above, just with an arbitrary directory instead of `~`.

If it is a directory, `ls` it if appropriate. Otherwise, `cd` into it and `exec` into the rest of the commands +
If it is an executable file, execute it. +
If it is a regular file, use `xdg-open` on it to open it.

If there are no children, we execute "$1" as a shell command.
You could replace this part with you favourite shell interpreter
e.g `fish`, `zsh`, `bash`. Or even something non-interactive such as `execlineb`.
This flexibility is one of the most powerful parts of Xiki.

If there is a child, then we shift and exec, essentially executing the child command instead of the parent.
This is what allows our `seq` example from above to function.

This may seem a little dangerous.

For example one may `cat` a file and then accidentally execute its contents.
This may be desirable at times(e.g to get a shellscript notebook), but you may not like this.
You can fix this(if you wish to do so) by simply replacing the last three lines with an unconditional exec

----
- [ -z "$2" ] && exec sh -c "$1"
- shift
- exec xiki "$@"
+ exec sh -c "$1"
----

== Xiki as plain text

You have seen some various examples of Xiki being useful to do a lot of interesting things.

The most powerful aspect of Xiki is the fact that it is plain text.
It is possible to save a Xiki buffer and then reopen it at a later time!

This allows Xiki to replace features like shell aliases.
Because instead aliasing common commands.
You can simply save them all in a file

----
cargo fmt
cargo build
cargo run
----

Files saved with the `.menu` extension are understood to be Xiki,
and are enabled with Xiki features by default.

Now, you can simply press `<ret>` on whichever command you want without ever having to type a single word!

Thanks to the `.*\.menu` command, pressing `<ret>` on such a filename will `cat` the file, while allowing executing the children.

== Conclusion

Before you go be sure to

----
rm -rf /tmp/xiki-tutorial
----
